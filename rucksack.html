<html><head><title>Rucksack - Rucksack API Reference</title><link href="doc.css" rel="stylesheet" type="text/css"></head><body><h1>Rucksack</h1><h2>EXTERNAL SYMBOLS</h2><div class="symbol"> <ul><li>Class: <strong> rucksack-error</strong>  inherits (error)</li></ul><dl><dt> <strong> rucksack</strong>  Reader: rucksack</small> </dt> </dl>  <ul><li>Method: <strong> print-object</strong>  [(error rucksack-error) stream]</li><li>Function: <strong> rucksack-error</strong>  [class &amp;rest args]</li><li>Class: <strong> transaction-conflict</strong>  inherits (rucksack-error)</li></ul><dl><dt> <strong> transaction</strong>  Reader: transaction</small> </dt> <dt> <strong> old-transaction</strong>  Reader: old-transaction</small> </dt> <dt> <strong> object-id</strong>  Reader: object-id</small> </dt> </dl>  <ul><li>Method: <strong> print-object</strong>  [(error transaction-conflict) stream]</li><li><p>Class: <strong> simple-rucksack-error</strong>  inherits (rucksack-error simple-error)</p></li><li><p>Method: <strong> print-object</strong>  [(error simple-rucksack-error) stream]</p></li><li>Function: <strong> simple-rucksack-error</strong>  [format-string &amp;rest format-args]</li><li><p>Class: <strong> internal-rucksack-error</strong>  inherits (rucksack-error simple-error)</p></li><li><p>Method: <strong> print-object</strong>  [(error internal-rucksack-error) stream]</p></li><li>Function: <strong> internal-rucksack-error</strong>  [format-string &amp;rest format-args]</li><li>Class: <strong> slot-error</strong>  inherits (rucksack-error)</li></ul><dl><dt> <strong> object</strong>  Reader: slot-error-object</small> </dt> <dt> <strong> slot-name</strong>  Reader: slot-error-name</small> </dt> <dt> <strong> value</strong>  Reader: slot-error-value</small> </dt> </dl>  <ul><li>Class: <strong> duplicate-slot-value</strong>  inherits (slot-error)</li></ul><dl><dt> <strong> other-object</strong>  Reader: slot-error-other-object</small> </dt> </dl>  <ul><li>Method: <strong> print-object</strong>  [(error duplicate-slot-value) stream]</li><li>Class: <strong> persistent-class</strong>  inherits (standard-class)</li></ul><dl><dt> <strong> persistent-slots</strong>  Accessor: class-persistent-slots</small> </dt> <dt> <strong> index</strong> </small> </dt> <dd> Can be either NIL (for no class index) or T (for the standard class index).  Default value is NIL.</dd> <dt> <strong> changed-p</strong>  Accessor: class-changed-p</small> </dt> <dd> True iff the class definition was changed but the schemas haven't been updated yet.  This flag is necessary because some MOP implementations don't call FINALIZE-INHERITANCE when a class was redefined and a new instance of the redefined class is created.</dd> </dl>  <ul><li>Method: <strong> validate-superclass</strong>  [(class standard-class) (superclass persistent-class)]</li><li>Method: <strong> validate-superclass</strong>  [(class persistent-class) (superclass standard-class)]</li><li>Method: <strong> initialize-instance</strong>  [(class persistent-class) &amp;rest args &amp;key direct-superclasses &amp;allow-other-keys]</li><li>Method: <strong> reinitialize-instance</strong>  [(class persistent-class) &amp;rest args &amp;key direct-superclasses &amp;allow-other-keys]</li><li>Method: <strong> finalize-inheritance</strong>  [(class persistent-class)]</li><li>Method: <strong> direct-slot-definition-class</strong>  [(class persistent-class) &amp;rest initargs]</li><li>Method: <strong> effective-slot-definition-class</strong>  [(class persistent-class) &amp;rest initargs]</li><li>Method: <strong> compute-effective-slot-definition</strong>  [(class persistent-class) slot-name direct-slot-definitions]</li><li>Generic: <strong> heap-stream</strong>  [heap]<pre> Returns the heap's stream.</pre></li><li>Generic: <strong> heap-end</strong>  [heap]<pre> Returns the end of the heap.</pre></li><li>Class: <strong> heap</strong>  inherits (standard-object)</li></ul><dl><dt> <strong> stream</strong>  Accessor: heap-stream</small> </dt> <dt> <strong> cell-buffer</strong>  Reader: cell-buffer</small> </dt> <dt> <strong> end</strong>  Accessor: heap-end</small> </dt> <dd> The end of the heap.  For free-list heaps, this number is stored in the first heap cell. For appending heaps, it's stored in the end of the file.</dd> <dt> <strong> max-size</strong>  Accessor: max-heap-size</small> </dt> <dd> The maximum size (in octets) for the heap. If nil, the heap is allowed to expand indefinitely.</dd> <dt> <strong> nr-allocated-octets</strong>  Accessor: nr-allocated-octets</small> </dt> <dd> The number of octets that have been allocated by ALLOCATE-BLOCK since the last time that RESET-ALLOCATION-COUNTER was called.</dd> </dl>  <ul><li>Function: <strong> open-heap</strong>  [pathname &amp;key (class (quote heap)) rucksack (options (quote nil)) (if-exists :overwrite) (if-does-not-exist :create)]</li><li>Method: <strong> close-heap</strong>  [(heap heap)]</li><li>Class: <strong> free-list-heap</strong>  inherits (heap)<pre> This heap uses a 'segregated free list' system: the<br /> first list contains 16-octet blocks (including the header), the second<br /> list contains 32-octet blocks, the third has 64-octet blocks, etc.  When<br /> there are N free lists, the last is for blocks of 16*2^(N-1) octets.<br /> <br /> Each block starts with an 8-octet header.  If a block is in use, the<br /> header contains the block's size.  If a block is still free, the header<br /> contains a pointer to the next block on the same free list.</pre></li></ul><dl><dt> <strong> nr-free-lists</strong>  Reader: nr-free-lists</small> </dt> <dt> <strong> starts</strong> </small> </dt> <dd> An array with the starts of each free-list.  This is an in-memory version of the array that's in the beginning of the heap.</dd> <dt> <strong> min-block-size</strong>  Reader: min-block-size</small> </dt> <dd> The size of the smallest blocks.  This must be a power of 2.</dd> <dt> <strong> expansion-size</strong>  Reader: expansion-size</small> </dt> <dd> The minimum number of bytes that will be used to expand a free-list.</dd> </dl>  <ul><li>Method: <strong> initialize-instance</strong>  [(heap free-list-heap) &amp;key &amp;allow-other-keys]</li><li><p>Class: <strong> simple-free-list-heap</strong>  inherits (free-list-heap)<pre> All blocks in a simple free list heap have the same size.</pre></p></li><li><p>Method: <strong> print-object</strong>  [(schema schema) stream]</p></li><li>Class: <strong> mark-and-sweep-heap</strong>  inherits (garbage-collector free-list-heap serializer)</li></ul><dl><dt> <strong> nr-object-bytes-marked</strong>  Accessor: nr-object-bytes-marked</small> </dt> <dt> <strong> nr-heap-bytes-scanned</strong>  Accessor: nr-heap-bytes-scanned</small> </dt> <dt> <strong> nr-heap-bytes-sweeped</strong>  Accessor: nr-heap-bytes-sweeped</small> </dt> <dt> <strong> nr-object-bytes-sweeped</strong>  Accessor: nr-object-bytes-sweeped</small> </dt> <dt> <strong> max-heap-end</strong>  Accessor: max-heap-end</small> </dt> <dd> The maximum acceptable value for heap-end during the current garbage collection.</dd> <dt> <strong> grow-size</strong>  Accessor: grow-size</small> </dt> <dd> Specifies a minimum amount to grow the heap when it needs to grow. If 'grow size' is an integer, the expected growth rate is additive and the integer is the number of octets to add; if it is a float, the expected growth rate for the heap is multiplicative and the float is the ratio of the new size to the old size.  (The actual size might be rounded up.)</dd> </dl>  <ul><li>Method: <strong> initialize-instance</strong>  [(heap mark-and-sweep-heap) &amp;key size &amp;allow-other-keys]</li><li>Method: <strong> close-heap</strong>  [(heap mark-and-sweep-heap)]</li><li>Generic: <strong> close-cache</strong>  [cache &amp;key commit]<pre> Closes the cache.  If COMMIT is true (which is the<br /> default), the objects in the cache will be written to disk before<br /> closing the cache.</pre></li><li>Generic: <strong> cache-size</strong>  [cache]<pre> Returns the number of non-dirty objects that the<br /> cache may keep in memory.</pre></li><li>Generic: <strong> cache-count</strong>  [cache]<pre> Returns the number of objects (both dirty and<br /> non-dirty) in the cache.</pre></li><li>Generic: <strong> cache-create-object</strong>  [object cache]<pre> Adds a new object to the cache and returns an<br /> object id that can be used to retrieve the object from the cache.<br /> Don't use this function twice for the same object.</pre></li><li>Generic: <strong> cache-get-object</strong>  [object-id cache]<pre> Retrieves the object with the given id from the<br /> cache and returns that object.</pre></li><li>Generic: <strong> cache-commit</strong>  [cache]<pre> Makes sure that all changes to the cache are<br /> written to disk.</pre></li><li>Generic: <strong> cache-rollback</strong>  [cache]<pre> Undoes all cache changes that were made since the<br /> last cache-commit.</pre></li><li>Generic: <strong> cache-recover</strong>  [cache]<pre> Undoes partially committed transactions to ensure<br /> that the cache is in a consistent state.</pre></li><li>Generic: <strong> open-transaction</strong>  [cache transaction]<pre> Adds a transaction to the set of open<br /> transactions.</pre></li><li>Generic: <strong> close-transaction</strong>  [cache transaction]<pre> Removes a transaction from the set of open<br /> transactions.</pre></li><li>Generic: <strong> map-transactions</strong>  [cache function]<pre> Applies a function to each open transaction in a<br /> cache.</pre></li><li><p>Class: <strong> cache</strong>  inherits (standard-object)</p></li><li><p>Class: <strong> standard-cache</strong>  inherits (cache)</p></li></ul><dl><dt> <strong> heap</strong>  Reader: heap</small> </dt> <dt> <strong> schema-table</strong>  Reader: schema-table</small> </dt> <dt> <strong> rucksack</strong>  Reader: rucksack</small> </dt> <dd> Back pointer to the rucksack.</dd> <dt> <strong> objects</strong>  Reader: objects</small> </dt> <dd> A hash-table (from id to object) containing the youngest committed version of all objects that are currently kept in memory but are not dirty.  ('The youngest version' means the version belonging to the youngest committed transaction.)</dd> <dt> <strong> queue</strong>  Reader: queue</small> </dt> <dd> A queue of the ids of all non-dirty objects that are currently in the cache memory.  Whenever an object is retrieved (i.e. read), it's added to the queue.  If an object-id is in this queue, it is not necessarily in the OBJECTS hash-table.</dd> <dt> <strong> last-timestamp</strong>  Accessor: last-timestamp</small> </dt> <dt> <strong> transaction-id-helper</strong>  Accessor: transaction-id-helper</small> </dt> <dt> <strong> transactions</strong>  Reader: transactions</small> </dt> <dd> A mapping from transaction ids to transactions.  Contains only open transactions, i.e. transactions that haven't been rolled back or committed.</dd> <dt> <strong> size</strong>  Accessor: cache-size</small> </dt> <dd> The maximum number of non-dirty objects that will be kept in the cache memory.</dd> <dt> <strong> shrink-ratio</strong>  Accessor: cache-shrink-ratio</small> </dt> <dd> A number between 0 and 1.  When the cache is full, i.e. when there are at least SIZE (non-dirty) objects in the queue, it will be shrunk by removing (1 - SHRINK-RATIO) * SIZE objects.</dd> </dl>  <ul><li>Method: <strong> print-object</strong>  [(cache standard-cache) stream]</li><li>Function: <strong> open-cache</strong>  [directory &amp;rest args &amp;key (class (quote standard-cache)) &amp;allow-other-keys]</li><li>Method: <strong> close-cache</strong>  [(cache standard-cache) &amp;key (commit t)]</li><li>Macro: <strong> with-cache</strong>  [(cache directory &amp;rest options) &amp;body body]</li><li>Method: <strong> initialize-instance</strong>  [(cache standard-cache) &amp;key directory (heap-class (quote mark-and-sweep-heap)) (heap-options (quote nil)) (if-exists :overwrite) (if-does-not-exist :create) (size 100000) &amp;allow-other-keys]</li><li>Method: <strong> cache-count</strong>  [(cache standard-cache)]</li><li>Method: <strong> cache-create-object</strong>  [object (cache standard-cache)]</li><li>Method: <strong> cache-touch-object</strong>  [object (cache standard-cache)]<pre> Checks for transaction conflicts and signals a transaction conflict<br /> if necessary.  Change the object's status to dirty.  If the object is<br /> already dirty, nothing happens.</pre></li><li>Method: <strong> cache-get-object</strong>  [object-id (cache standard-cache)]</li><li>Method: <strong> open-transaction</strong>  [(cache standard-cache) transaction]</li><li>Method: <strong> close-transaction</strong>  [(cache standard-cache) transaction]</li><li>Method: <strong> map-transactions</strong>  [(cache standard-cache) function]</li><li>Method: <strong> cache-rollback</strong>  [(cache standard-cache)]</li><li>Method: <strong> cache-commit</strong>  [(cache standard-cache)]</li><li>Method: <strong> cache-recover</strong>  [(cache standard-cache)]</li><li>Variable: <strong> *rucksack*</strong></li><li>Function: <strong> current-rucksack</strong></li><li>Generic: <strong> object-id</strong>  [object]<pre> Returns the object id of a persistent-object or<br /> persistent-data.</pre></li><li>Generic: <strong> p-eql</strong>  [x y]<pre> The persistent equivalent of EQL.</pre></li><li>Method: <strong> p-eql</strong>  [a b]</li><li>Function: <strong> cache</strong>  [object]</li><li>Class: <strong> persistent-data</strong>  inherits (standard-object)<pre> PERSISTENT-DATA classes do not have PERSISTENT-CLASS as metaclass<br /> because we don't want to specialize SLOT-VALUE-USING-CLASS &amp; friends<br /> for persistent-data instances.  Their contents are accessed by special<br /> functions like P-CAR instead.</pre></li></ul><dl><dt> <strong> object-id</strong>  Reader: object-id</small> </dt> <dt> <strong> transaction-id</strong>  Reader: transaction-id</small> </dt> <dt> <strong> rucksack</strong>  Reader: rucksack</small> </dt> <dt> <strong> contents</strong>  Accessor: contents</small> </dt> </dl>  <ul><li>Method: <strong> print-object</strong>  [(object persistent-data) stream]</li><li>Method: <strong> p-eql</strong>  [(a persistent-data) (b persistent-data)]</li><li><p>Class: <strong> persistent-array</strong>  inherits (persistent-data)</p></li><li><p>Function: <strong> p-make-array</strong>  [dimensions &amp;rest options &amp;key &amp;allow-other-keys]</p></li><li>Method: <strong> p-aref</strong>  [(array persistent-array) &amp;rest indices]</li><li>Method: <strong> p-array-dimensions</strong>  [(array persistent-array)]</li><li><p>Class: <strong> persistent-cons</strong>  inherits (persistent-data)</p></li><li><p>Function: <strong> p-cons</strong>  [car cdr]</p></li><li>Method: <strong> p-car</strong>  [(cons persistent-cons)]</li><li>Method: <strong> p-car</strong>  [(x (eql nil))]</li><li>Method: <strong> p-cdr</strong>  [(cons persistent-cons)]</li><li>Method: <strong> p-cdr</strong>  [(x (eql nil))]</li><li>Function: <strong> p-list</strong>  [&amp;rest objects]</li><li>Function: <strong> unwrap-persistent-list</strong>  [list]<pre> Converts a persistent list to a 'normal' Lisp list.</pre></li><li>Function: <strong> p-caar</strong>  [object]<pre> The persistent equivalent of CAAR.</pre></li><li>Function: <strong> p-cadr</strong>  [object]<pre> The persistent equivalenet of CADR.</pre></li><li>Function: <strong> p-cdar</strong>  [object]<pre> The persistent equivalent of CDAR.</pre></li><li>Function: <strong> p-cddr</strong>  [object]<pre> The persistent equivalent of CDDR.</pre></li><li>Method: <strong> p-consp</strong>  [(object persistent-cons)]</li><li>Method: <strong> p-consp</strong>  [(object t)]</li><li>Method: <strong> p-endp</strong>  [(object (eql nil))]</li><li>Method: <strong> p-endp</strong>  [(object persistent-cons)]</li><li>Method: <strong> p-endp</strong>  [(object t)]</li><li>Function: <strong> p-last</strong>  [list &amp;optional (n 1)]<pre> Returns the last persistent cons cell of a persistent list (or<br /> NIL if the list is empty).</pre></li><li>Function: <strong> p-mapcar</strong>  [function list]</li><li>Function: <strong> p-mapc</strong>  [function list]</li><li>Function: <strong> p-maplist</strong>  [function list]</li><li>Function: <strong> p-mapl</strong>  [function list]</li><li>Function: <strong> p-member-if</strong>  [predicate list &amp;key key]</li><li>Macro: <strong> p-pop</strong>  [place &amp;environment env]<pre> Pop an item from the persistent list specified by PLACE.</pre></li><li>Macro: <strong> p-push</strong>  [item place &amp;environment env]<pre> Push ITEM onto the persistent list specified by PLACE.  Return the<br /> modified persistent list. ITEM is evaluated before place.</pre></li><li>Method: <strong> p-length</strong>  [(vector persistent-array)]</li><li>Method: <strong> p-length</strong>  [(list persistent-cons)]</li><li>Method: <strong> p-find</strong>  [value (vector persistent-array) &amp;key (key (function identity)) (test (function p-eql)) (start 0) (end nil)]</li><li>Method: <strong> p-find</strong>  [value (list persistent-cons) &amp;key (key (function identity)) (test (function p-eql)) (start 0) (end nil)]</li><li>Method: <strong> p-find</strong>  [value (list (eql nil)) &amp;key &amp;allow-other-keys]</li><li>Method: <strong> p-position</strong>  [value (vector persistent-array) &amp;key (key (function identity)) (test (function p-eql)) (start 0) (end nil)]</li><li>Method: <strong> p-position</strong>  [value (list persistent-cons) &amp;key (key (function identity)) (test (function p-eql)) (start 0) (end nil)]</li><li>Method: <strong> p-replace</strong>  [(vector-1 persistent-array) (vector-2 persistent-array) &amp;key (start1 0) end1 (start2 0) end2]</li><li>Method: <strong> p-delete-if</strong>  [test (list persistent-cons) &amp;key (from-end nil) (start 0) end count key]</li><li>Class: <strong> persistent-object</strong>  inherits (standard-object)<pre> Classes of metaclass PERSISTENT-CLASS automatically<br /> inherit from this class.</pre></li></ul><dl><dt> <strong> object-id</strong>  Reader: object-id</small> </dt> <dt> <strong> transaction-id</strong>  Reader: transaction-id</small> </dt> <dt> <strong> rucksack</strong>  Reader: rucksack</small> </dt> </dl>  <ul><li>Method: <strong> initialize-instance</strong>  [(object persistent-object) &amp;rest args &amp;key rucksack (dont-index nil) &amp;allow-other-keys]</li><li>Method: <strong> print-object</strong>  [(object persistent-object) stream]</li><li>Method: <strong> p-eql</strong>  [(a persistent-object) (b persistent-object)]</li><li>Method: <strong> p-eql</strong>  [(a persistent-data) (b persistent-object)]</li><li>Method: <strong> p-eql</strong>  [(a persistent-object) (b persistent-data)]</li><li>Method: <strong> slot-value-using-class</strong>  [(class persistent-class) object slot]</li><li>Method: <strong> slot-makunbound-using-class</strong>  [(class persistent-class) object slot-name-or-def]</li><li>Generic: <strong> update-persistent-instance-for-redefined-class</strong>  [instance added-slots discarded-slots property-list &amp;key]</li><li>Method: <strong> update-persistent-instance-for-redefined-class</strong>  [(instance persistent-object) added-slots discarded-slots plist &amp;key]</li><li>Method: <strong> update-instance-for-redefined-class</strong>  [(object persistent-object) added-slots discarded-slots plist &amp;rest initargs &amp;key]</li><li>Generic: <strong> btree-nr-keys</strong>  [btree]<pre> Returns the number of keys in a btree.</pre></li><li>Generic: <strong> btree-nr-values</strong>  [btree]<pre> Returns the number of values in a btree.</pre></li><li>Generic: <strong> btree-search</strong>  [btree key &amp;key errorp default-value]<pre> Returns the value (or persistent list of values, for btrees that<br /> don't have unique keys) associated with KEY.  If the btree has<br /> non-unique keys and no value is found, the empty list is returned.  If<br /> the btree has unique keys and no value is found, the result depends on<br /> the ERRORP option: if ERRORP is true, a btree-search-error is<br /> signalled; otherwise, DEFAULT-VALUE is returned.</pre></li><li>Generic: <strong> btree-insert</strong>  [btree key value &amp;key if-exists]<pre> Adds an association from KEY to VALUE to a btree.<br /> <br /> IF-EXISTS can be either :OVERWRITE (default) or :ERROR.<br /> <br /> If the btree has unique keys (see BTREE-UNIQUE-KEYS-P) and KEY is<br /> already associated with another (according to BTREE-VALUE=) value, the<br /> result depends on the IF-EXISTS option: if IF-EXISTS is :OVERWRITE,<br /> the old value is overwriten; if IF-EXISTS is :ERROR, a<br /> BTREE-KEY-ALREADY-PRESENT-ERROR is signaled.<br /> <br /> For btrees with non-unique keys, the IF-EXISTS option is ignored and<br /> VALUE is just added to the list of values associated with KEY (unless<br /> VALUE is already associated with KEY; in that case nothing<br /> happens).</pre></li><li>Generic: <strong> btree-delete</strong>  [btree key value &amp;key if-does-not-exist]<pre> Removes an association from KEY to VALUE from a btree.<br /> IF-DOES-NOT-EXIST can be either :IGNORE (default) or :ERROR.<br /> If there is no association from KEY to VALUE and IF-DOES-NOT-EXIST<br /> is :ERROR, a BTREE-DELETION-ERROR is signaled.</pre></li><li>Generic: <strong> btree-delete-key</strong>  [btree key &amp;key if-does-not-exist]<pre> Removes KEY and all associated values from a btree.<br /> IF-DOES-NOT-EXIST can be either :IGNORE (default) or :ERROR.<br /> <br /> For a btree with unique-keys that contains a value for KEY, this<br /> operation is identical to<br /> <br />   (btree-delete btree key (btree-search btree key))<br /> <br /> For a btree with non-unique keys, it's identical to<br /> <br />   (dolist (value (unwrap-persistent-list (btree-search btree key)))<br />     (btree-delete btree key value))</pre></li><li>Generic: <strong> map-btree</strong>  [btree function &amp;key min max include-min include-max order]<pre> Calls FUNCTION for all key/value associations in the btree where<br /> key is in the specified interval (this means that FUNCTION can be<br /> called with the same key more than once for btrees with non-unique<br /> keys). FUNCTION must be a binary function; the first argument is the<br /> btree key, the second argument is an associated value.<br /> <br /> MIN, MAX, INCLUDE-MIN and INCLUDE-MAX specify the interval.  The<br /> interval is left-open if MIN is nil, right-open if MAX is nil.  The<br /> interval is inclusive on the left if INCLUDE-MIN is true (and<br /> exclusive on the left otherwise).  The interval is inclusive on the<br /> right if INCLUDE-MAX is true (and exclusive on the right otherwise).<br /> <br /> ORDER is either :ASCENDING (default) or :DESCENDING.</pre></li><li>Generic: <strong> map-btree-keys</strong>  [btree function &amp;key min max include-min include-max order]<pre> Calls FUNCTION for all keys in the btree where key is in the<br /> specified interval. FUNCTION must be a binary function; the first<br /> argument is the btree key, the second argument is the btree value (or<br /> persistent list of values, for btrees with non-unique keys).  FUNCTION<br /> will be called exactly once for each key in the btree.<br /> <br /> MIN, MAX, INCLUDE-MIN and INCLUDE-MAX specify the interval.  The<br /> interval is left-open if MIN is nil, right-open if MAX is nil.  The<br /> interval is inclusive on the left if INCLUDE-MIN is true (and<br /> exclusive on the left otherwise).  The interval is inclusive on the<br /> right if INCLUDE-MAX is true (and exclusive on the right otherwise).<br /> <br /> ORDER is either :ASCENDING (default) or :DESCENDING.</pre></li><li>Class: <strong> btree-error</strong>  inherits (error)</li></ul><dl><dt> <strong> btree</strong>  Reader: btree-error-btree</small> </dt> </dl>  <ul><li>Class: <strong> btree-search-error</strong>  inherits (btree-error)</li></ul><dl><dt> <strong> key</strong>  Reader: btree-error-key</small> </dt> </dl>  <ul><li>Class: <strong> btree-insertion-error</strong>  inherits (btree-error)</li></ul><dl><dt> <strong> key</strong>  Reader: btree-error-key</small> </dt> <dt> <strong> value</strong>  Reader: btree-error-value</small> </dt> </dl>  <ul><li><p>Class: <strong> btree-key-already-present-error</strong>  inherits (btree-insertion-error)</p></li><li><p>Class: <strong> btree-type-error</strong>  inherits (btree-error type-error)</p></li><li><p>Class: <strong> btree</strong>  inherits (persistent-object)</p></li></ul><dl><dt> <strong> key<</strong> </small> </dt> <dt> <strong> value=</strong> </small> </dt> <dd> This is only used for btrees with non-unique keys.</dd> <dt> <strong> key-key</strong>  Reader: btree-key-key</small> </dt> <dd> A unary function that is applied to a btree key before comparing it to another key with a key comparison predicate like BTREE-KEY<.</dd> <dt> <strong> value-key</strong>  Reader: btree-value-key</small> </dt> <dd> A unary function that is applied to a btree value before comparing it to another value with the BTREE-VALUE= predicate.</dd> <dt> <strong> node-class</strong>  Reader: btree-node-class</small> </dt> <dt> <strong> max-node-size</strong>  Reader: btree-max-node-size</small> </dt> <dd> An integer specifying the preferred maximum number of keys per btree node.</dd> <dt> <strong> unique-keys-p</strong>  Reader: btree-unique-keys-p</small> </dt> <dd> If false, one key can correspond to more than one value. In that case, the values are assumed to be objects for which the function OBJECT-ID is defined (and returns a unique integer).</dd> <dt> <strong> key-type</strong>  Reader: btree-key-type</small> </dt> <dd> The type of all keys.</dd> <dt> <strong> value-type</strong>  Reader: btree-value-type</small> </dt> <dd> The type of all values.</dd> <dt> <strong> root</strong>  Accessor: btree-root</small> </dt> </dl>  <ul><li>Method: <strong> initialize-instance</strong>  [(btree btree) &amp;rest initargs &amp;key key&lt; key-key value= value-key &amp;allow-other-keys]</li><li>Method: <strong> btree-key&lt;</strong> [(btree btree)]</li><li>Method: <strong> btree-key=</strong>  [(btree btree)]</li><li>Method: <strong> btree-key&gt;=</strong>  [(btree btree)]</li><li>Method: <strong> btree-key&lt;=</strong>  [(btree btree)]</li><li>Method: <strong> btree-key&gt;</strong> [(btree btree)]</li><li>Method: <strong> btree-value=</strong>  [(btree btree)]</li><li>Method: <strong> initialize-instance</strong>  [(node bnode) &amp;key btree &amp;allow-other-keys]</li><li>Method: <strong> print-object</strong>  [(node bnode) stream]</li><li>Method: <strong> btree-nr-keys</strong>  [(btree btree)]</li><li>Method: <strong> btree-nr-values</strong>  [(btree btree)]</li><li>Method: <strong> btree-search</strong>  [btree key &amp;key (errorp t) (default-value nil)]</li><li>Method: <strong> btree-insert</strong>  [(btree btree) key value &amp;key (if-exists :overwrite)]</li><li>Method: <strong> btree-delete</strong>  [(btree btree) key value &amp;key (if-does-not-exist :ignore)]</li><li>Method: <strong> btree-delete-key</strong>  [(btree btree) key &amp;key (if-does-not-exist :ignore)]</li><li>Method: <strong> map-btree</strong>  [(btree btree) function &amp;key min max include-min include-max (order :ascending)]</li><li>Method: <strong> map-btree-keys</strong>  [(btree btree) function &amp;key min max include-min include-max (order :ascending)]</li><li>Generic: <strong> map-index</strong>  [index function &amp;key equal min max include-min include-max order]<pre> Calls FUNCTION for all key/value pairs in the btree<br /> where key is in the specified interval. FUNCTION must be a binary<br /> function; the first argument is the index key, the second argument is<br /> the index value (or list of values, for indexes with non-unique keys).<br /> <br /> If EQUAL is specified, the other arguments are ignored; the function<br /> will be called once (if there is a key with the same value as EQUAL)<br /> or not at all (if there is no such key).<br /> <br /> MIN, MAX, INCLUDE-MIN and INCLUDE-MAX specify the interval.  The<br /> interval is left-open if MIN is nil, right-open if MAX is nil.  The<br /> interval is inclusive on the left if INCLUDE-MIN is true (and<br /> exclusive on the left otherwise).  The interval is inclusive on the<br /> right if INCLUDE-MAX is true (and exclusive on the right otherwise).<br /> <br /> ORDER is either :ASCENDING (default) or :DESCENDING.</pre></li><li>Generic: <strong> index-insert</strong>  [index key value &amp;key if-exists]<pre> Insert a key/value pair into an index.  IF-EXISTS can be either<br /> :OVERWRITE (default) or :ERROR.</pre></li><li>Generic: <strong> index-delete</strong>  [index key value &amp;key if-does-not-exist]<pre> Remove a key/value pair from an index.  IF-DOES-NOT-EXIST can be<br /> either :IGNORE (default) or :ERROR.</pre></li><li>Method: <strong> print-object</strong>  [(index index) stream]</li><li>Method: <strong> map-index</strong>  [(index index) function &amp;rest args &amp;key min max include-min include-max (equal nil) (order :ascending)]</li><li>Method: <strong> index-insert</strong>  [(index index) key value &amp;key (if-exists :overwrite)]</li><li>Method: <strong> index-delete</strong>  [(index index) key value &amp;key (if-does-not-exist :ignore)]</li><li>Function: <strong> make-index</strong>  [index-spec unique-keys-p &amp;key (class (quote index))]</li><li>Function: <strong> define-index-spec</strong>  [name spec &amp;key (if-exists :overwrite)]<pre> NAME must be a keyword.  SPEC must be an index spec.  IF-EXISTS must be<br /> either :OVERWRITE (default) or :ERROR.</pre></li><li>Function: <strong> find-index-spec</strong>  [name &amp;key (errorp t)]</li><li>Generic: <strong> add-rucksack-root</strong>  [object rucksack]<pre> Adds an object to the root set of a rucksack.</pre></li><li>Generic: <strong> map-rucksack-roots</strong>  [function rucksack]<pre> Applies a function to all objects in the root set of a rucksack.</pre></li><li>Generic: <strong> rucksack-roots</strong>  [rucksack]<pre> Returns a list with all objects in the root set of a rucksack.  You<br /> shouldn't modify this list.</pre></li><li>Generic: <strong> rucksack-cache</strong>  [rucksack]<pre> Returns the cache for a rucksack.</pre></li><li>Generic: <strong> rucksack-directory</strong>  [rucksack]<pre> Returns a pathname for the directory that contains all files of a<br /> rucksack.</pre></li><li>Generic: <strong> rucksack-commit</strong>  [rucksack]<pre> Ensures that all in-memory data is saved to disk.</pre></li><li>Generic: <strong> rucksack-rollback</strong>  [rucksack]<pre> ....</pre></li><li>Generic: <strong> rucksack-add-class-index</strong>  [rucksack class-designator &amp;key errorp]</li><li>Generic: <strong> rucksack-remove-class-index</strong>  [rucksack class-designator &amp;key errorp]</li><li>Generic: <strong> rucksack-class-index</strong>  [rucksack class-designator &amp;key errorp]<pre> Returns the class index for a class designator.</pre></li><li>Generic: <strong> rucksack-map-class-indexes</strong>  [rucksack function]<pre> FUNCTION must take two arguments: a class name and a class index.<br /> It is called for all class indexes in the specified rucksack.</pre></li><li>Generic: <strong> rucksack-make-class-index</strong>  [rucksack class &amp;key index-spec]<pre> Creates a new class index and returns that index.  INDEX-SPEC<br /> specifies the kind of index that must be created (if not supplied, the<br /> rucksack's default class index spec will be used.</pre></li><li>Generic: <strong> rucksack-add-slot-index</strong>  [rucksack class-designator slot index-spec unique-p &amp;key errorp]<pre> Creates a new slot index for the slot designated by<br /> CLASS-DESIGNATOR and SLOT.  The type of index is specified by<br /> INDEX-SPEC.  Returns the new index.  Signals an error if ERRORP is T<br /> and there already is an index for the designated slot.</pre></li><li>Generic: <strong> rucksack-remove-slot-index</strong>  [rucksack class-designator slot &amp;key errorp]</li><li>Generic: <strong> rucksack-slot-index</strong>  [rucksack class-designator slot &amp;key errorp include-superclasses]<pre> Returns the slot index for the slot specified by CLASS-DESIGNATOR<br /> and SLOT.</pre></li><li>Generic: <strong> rucksack-map-slot-indexes</strong>  [rucksack function &amp;key class include-subclasses]<pre> FUNCTION must take three arguments: a class name, a slot name and<br /> a slot index.  It is called for all slot indexes in the specified<br /> rucksack.<br />   CLASS defaults to T, meaning all classes.<br />   INCLUDE-SUBCLASSES defaults to T.</pre></li><li>Generic: <strong> rucksack-maybe-index-changed-slot</strong>  [rucksack class object slot old-value new-value old-boundp new-boundp]<pre> This function is called after a slot has changed.  OLD-VALUE is the<br /> slot's value before the change, NEW-VALUE is the current value.<br /> OLD-BOUNDP is true iff the slot was bound before the change,<br /> NEW-BOUNDP is true iff the slot is currently bound.</pre></li><li>Generic: <strong> rucksack-maybe-index-new-object</strong>  [rucksack class-designator object]<pre> Adds the object id of OBJECT to the class index for the class<br /> designated by CLASS-DESIGNATOR.  If there is no such class index, it<br /> does nothing.</pre></li><li>Generic: <strong> rucksack-map-class</strong>  [rucksack class function &amp;key id-only include-subclasses]<pre>   FUNCTION is a unary function that gets called for all instances of<br /> the specified class.  Unindexed classes (i.e. classes for which the<br /> :indexed class option is nil) will be skipped.<br />   If ID-ONLY is T (default is NIL), the function will be called with<br /> object ids instead of 'real' objects.  This can be handy if you want to<br /> do more filtering before actually loading objects from disk.<br />   INCLUDE-SUBCLASSES defaults to T.</pre></li><li>Macro: <strong> rucksack-do-class</strong>  [(instance-var class &amp;key (rucksack (quote *rucksack*)) id-only (include-subclasses t)) &amp;body body]<pre> Evaluate BODY for each instance of CLASS, with INSTANCE-VAR<br /> successively bound to each instance.  See the documentation of<br /> RUCKSACK-MAP-CLASS for more details.</pre></li><li>Generic: <strong> rucksack-map-slot</strong>  [rucksack class slot function &amp;key equal min max include-min include-max order include-subclasses]<pre>  FUNCTION is a unary function that gets called for all instances of<br /> the specified class that have a slot value matching the EQUAL, MIN,<br /> MAX INCLUDE-MIN and INCLUDE-MAX arguments (see the documentation of<br /> MAP-INDEX for a description of these arguments).<br />   ORDER can be either :ASCENDING (default) or :DESCENDING; currently,<br /> the specified order will be respected for instances of one class but<br /> not across subclasses.<br />   If ID-ONLY is T (default is NIL), the function will be called with<br /> object ids instead of 'real' objects.  This can be handy if you want to<br /> do more filtering before actually loading objects from disk.<br />   INCLUDE-SUBCLASSES defaults to T.</pre></li><li>Macro: <strong> rucksack-do-slot</strong>  [(instance-var class slot &amp;rest args &amp;key (rucksack (quote *rucksack*)) equal min max include-min include-max order include-subclasses) &amp;body body]<pre> Evaluate BODY for each instance of CLASS where SLOT has the<br /> specified value. INSTANCE-VAR will be bound successively to each<br /> instance.  See the documentation of RUCKSACK-MAP-SLOT for more<br /> details.</pre></li><li>Generic: <strong> rucksack-delete-object</strong>  [rucksack object]<pre> Removes OBJECT from RUCKSACK, i.e. removes object from the<br /> rucksack roots (if it is a root) and from all class and slot indexes<br /> in which it appears.</pre></li><li>Variable: <strong> *transaction*</strong></li><li>Macro: <strong> with-transaction</strong>  [(&amp;rest args &amp;key (rucksack (quote (current-rucksack))) (inhibit-gc nil inhibit-gc-supplied-p) &amp;allow-other-keys) &amp;body body]</li><li><p>Class: <strong> rucksack</strong>  inherits (standard-object)</p></li><li><p>Class: <strong> standard-rucksack</strong>  inherits (rucksack)</p></li></ul><dl><dt> <strong> cache</strong>  Reader: rucksack-cache</small> </dt> <dt> <strong> directory</strong>  Reader: rucksack-directory</small> </dt> <dt> <strong> roots</strong> </small> </dt> <dd> A list with the object ids of all root objects, i.e.  the objects from which the garbage collector can reach all live objects.</dd> <dt> <strong> roots-changed-p</strong>  Accessor: roots-changed-p</small> </dt> <dt> <strong> highest-transaction-id</strong>  Accessor: highest-transaction-id</small> </dt> <dd> The highest transaction ID in the entire rucksack.  This is saved together with the roots.</dd> <dt> <strong> class-index-table</strong> </small> </dt> <dd> The object id of a btree mapping class names to class indexes.  Each class index contains the ids of all instances from a class; it maps object ids to objects.</dd> <dt> <strong> slot-index-tables</strong> </small> </dt> <dd> The object id of a btree mapping class names to slot index tables, where each slot index table is a btree mapping slot names to slot indexes.  Each slot index maps slot values to objects.</dd> </dl>  <ul><li>Method: <strong> print-object</strong>  [(rucksack rucksack) stream]</li><li>Method: <strong> initialize-instance</strong>  [(rucksack standard-rucksack) &amp;key (cache-class (quote lazy-cache)) (cache-args (quote nil)) &amp;allow-other-keys]</li><li>Method: <strong> add-rucksack-root</strong>  [object (rucksack standard-rucksack)]</li><li>Method: <strong> map-rucksack-roots</strong>  [function (rucksack standard-rucksack)]</li><li>Method: <strong> rucksack-roots</strong>  [(rucksack standard-rucksack)]</li><li>Function: <strong> open-rucksack</strong>  [directory-designator &amp;rest args &amp;key (class (quote serial-transaction-rucksack)) (if-exists :overwrite) (if-does-not-exist :create) (cache-class (quote lazy-cache)) (cache-args (quote nil)) &amp;allow-other-keys]<pre> Opens the rucksack in the directory designated by DIRECTORY-DESIGNATOR.<br />   :IF-DOES-NOT-EXIST can be either :CREATE (creates a new rucksack if the<br /> it does not exist; this is the default) or :ERROR (signals an error if<br /> the rucksack does not exist).<br />   :IF-EXISTS can be either :OVERWRITE (loads the rucksack if it exists;<br /> this is the default), :SUPERSEDE (deletes the existing rucksack and creates<br /> a new empty rucksack) or :ERROR (signals an error if the rucksack exists).</pre></li><li>Function: <strong> close-rucksack</strong>  [rucksack &amp;key (commit t)]</li><li>Function: <strong> commit</strong>  [&amp;key (rucksack (current-rucksack))]</li><li>Method: <strong> rucksack-commit</strong>  [(rucksack standard-rucksack)]</li><li>Function: <strong> rollback</strong>  [&amp;key (rucksack (current-rucksack))]</li><li>Method: <strong> rucksack-rollback</strong>  [(rucksack standard-rucksack)]</li><li>Macro: <strong> with-rucksack</strong>  [(rucksack directory &amp;rest args) &amp;body body]</li><li>Function: <strong> add-class-index</strong>  [class-designator &amp;key errorp]</li><li>Function: <strong> add-slot-index</strong>  [class-designator slot index-spec &amp;key (errorp nil)]</li><li>Function: <strong> remove-class-index</strong>  [class-designator &amp;key (errorp nil)]</li><li>Function: <strong> remove-slot-index</strong>  [class-designator slot &amp;key (errorp nil)]</li><li>Function: <strong> map-class-indexes</strong>  [function]</li><li>Function: <strong> map-slot-indexes</strong>  [function &amp;key (class t) (include-subclasses t)]</li><li>Method: <strong> rucksack-add-class-index</strong>  [(rucksack standard-rucksack) class &amp;key (errorp nil)]</li><li>Method: <strong> rucksack-make-class-index</strong>  [(rucksack standard-rucksack) class &amp;key (index-spec (quote (btree :key&lt; &lt; :value= p-eql)))]</li><li>Method: <strong> rucksack-remove-class-index</strong>  [(rucksack standard-rucksack) class &amp;key (errorp nil)]</li><li>Method: <strong> rucksack-map-class-indexes</strong>  [rucksack function]</li><li>Method: <strong> rucksack-class-index</strong>  [(rucksack standard-rucksack) class &amp;key (errorp nil)]</li><li>Method: <strong> rucksack-maybe-index-new-object</strong>  [(rucksack standard-rucksack) class object]</li><li>Method: <strong> rucksack-map-class</strong>  [(rucksack standard-rucksack) class function &amp;key (id-only nil) (include-subclasses t)]</li><li>Method: <strong> rucksack-add-slot-index</strong>  [(rucksack standard-rucksack) class slot index-spec unique-p &amp;key (errorp nil)]</li><li>Method: <strong> rucksack-remove-slot-index</strong>  [rucksack class slot &amp;key (errorp nil)]</li><li>Method: <strong> rucksack-map-slot-indexes</strong>  [(rucksack standard-rucksack) function &amp;key (class t) (include-subclasses t)]</li><li>Method: <strong> rucksack-maybe-index-changed-slot</strong>  [(rucksack standard-rucksack) class object slot old-value new-value old-boundp new-boundp]</li><li>Method: <strong> rucksack-slot-index</strong>  [(rucksack standard-rucksack) class slot &amp;key (errorp nil) (include-superclasses nil)]</li><li>Method: <strong> rucksack-map-slot</strong>  [(rucksack standard-rucksack) class slot function &amp;key min max include-min include-max (equal nil equal-supplied) (order :ascending) (include-subclasses t)]</li><li>Method: <strong> rucksack-delete-object</strong>  [(rucksack standard-rucksack) object]</li><li>Generic: <strong> transaction-start-1</strong>  [cache rucksack &amp;key &amp;allow-other-keys]<pre> Creates and returns a new transaction.</pre></li><li>Generic: <strong> transaction-commit-1</strong>  [transaction cache rucksack]<pre> Save all modified objects to disk.</pre></li><li><p>Class: <strong> transaction</strong>  inherits (standard-object)</p></li><li><p>Class: <strong> standard-transaction</strong>  inherits (transaction)</p></li></ul><dl><dt> <strong> id</strong>  Reader: transaction-id</small> </dt> <dt> <strong> dirty-objects</strong>  Reader: dirty-objects</small> </dt> <dd> A hash-table (from id to object) containing all objects of which the slot changes have not been written to disk yet.</dd> <dt> <strong> dirty-queue</strong>  Reader: dirty-queue</small> </dt> <dd> A queue with the ids of all objects that have been created or modified since the last commit.  The queue is in least-recently-dirtied-first order.  During a commit, the objects are written to disk in the same order (this is necessary to guarantee that the garbage collector never sees an id of an object that doesn't exist on disk yet.</dd> </dl>  <ul><li>Method: <strong> print-object</strong>  [(transaction transaction) stream]</li><li>Function: <strong> current-transaction</strong></li><li>Function: <strong> transaction-start</strong>  [&amp;rest args &amp;key (rucksack (current-rucksack)) &amp;allow-other-keys]</li><li>Method: <strong> transaction-start-1</strong>  [(cache standard-cache) (rucksack standard-rucksack) &amp;key &amp;allow-other-keys]</li><li>Method: <strong> transaction-start-1</strong>  [(cache standard-cache) (rucksack serial-transaction-rucksack) &amp;key &amp;allow-other-keys]</li><li>Method: <strong> transaction-commit-1</strong>  [(transaction standard-transaction) (cache standard-cache) (rucksack serial-transaction-rucksack)]</li><li>Function: <strong> transaction-commit</strong>  [transaction &amp;key (rucksack (current-rucksack))]<pre> Call transaction-commit-1 to do the real work.</pre></li><li>Method: <strong> transaction-commit-1</strong>  [(transaction standard-transaction) (cache standard-cache) (rucksack standard-rucksack)]</li><li>Function: <strong> transaction-rollback</strong>  [transaction &amp;key (rucksack (current-rucksack))] </div>  </li></ul></body></html>